From 580534ac9328838291bb1a312c5e634b12af2a9d Mon Sep 17 00:00:00 2001
From: Daniel Charles <daniel.charles@intel.com>
Date: Fri, 11 Oct 2019 17:33:59 +0000
Subject: [PATCH] not-ffmpeg: enable h264_qsv encoder and decoder

Minimum configuration to enable h264_qsv enc/dec for ClearLinux

This restores 5 files required for this to compoile and work.

Building targets are brought back and since it is compiling h.264 bits
it required to remove h264dsp from compilation as it is not needed and
it waterfalls into including other files that are not necessary.

This patch will need to be reworked on the next release bump, where
the files restored should be erased from remove_files.clearlinux before
running reduced.sh script

Signed-off-by: Daniel Charles <daniel.charles@intel.com>
---
 libavcodec/Makefile      |   3 +-
 libavcodec/h264_parser.c |   1 -
 libavcodec/h264_sei.c    | 522 ++++++++++++++++++++++++
 libavcodec/h264_sei.h    | 205 ++++++++++
 libavcodec/h264data.c    | 232 +++++++++++
 libavcodec/h264data.h    |  79 ++++
 libavcodec/h264dec.h     | 854 +++++++++++++++++++++++++++++++++++++++
 7 files changed, 1894 insertions(+), 2 deletions(-)
 create mode 100644 libavcodec/h264_sei.c
 create mode 100644 libavcodec/h264_sei.h
 create mode 100644 libavcodec/h264data.c
 create mode 100644 libavcodec/h264data.h
 create mode 100644 libavcodec/h264dec.h

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 44425c3296..1f5d5b99bb 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -82,7 +82,6 @@ OBJS-$(CONFIG_FMTCONVERT)              += fmtconvert.o
 OBJS-$(CONFIG_GOLOMB)                  += golomb.o
 OBJS-$(CONFIG_H263DSP)                 += h263dsp.o
 OBJS-$(CONFIG_H264CHROMA)              += h264chroma.o
-OBJS-$(CONFIG_H264DSP)                 += h264dsp.o h264idct.o
 OBJS-$(CONFIG_H264PARSE)               += h264_parse.o h2645_parse.o h264_ps.o
 OBJS-$(CONFIG_H264PRED)                += h264pred.o
 OBJS-$(CONFIG_H264QPEL)                += h264qpel.o
@@ -188,6 +187,8 @@ OBJS-$(CONFIG_DVAUDIO_DECODER)         += dvaudiodec.o
 OBJS-$(CONFIG_FIC_DECODER)             += fic.o
 OBJS-$(CONFIG_GIF_DECODER)             += gifdec.o lzw.o
 OBJS-$(CONFIG_GIF_ENCODER)             += gif.o lzwenc.o
+OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec_h2645.o
+OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
 OBJS-$(CONFIG_H264_VAAPI_ENCODER)      += vaapi_encode_h264.o h264_levels.o
 OBJS-$(CONFIG_HCOM_DECODER)            += hcom.o
 OBJS-$(CONFIG_HEVC_VAAPI_ENCODER)      += vaapi_encode_h265.o h265_profile_level.o
diff --git a/libavcodec/h264_parser.c b/libavcodec/h264_parser.c
index 5f9a9c46ef..640ac75a82 100644
--- a/libavcodec/h264_parser.c
+++ b/libavcodec/h264_parser.c
@@ -701,7 +701,6 @@ static av_cold int init(AVCodecParserContext *s)
 
     p->reference_dts = AV_NOPTS_VALUE;
     p->last_frame_num = INT_MAX;
-    ff_h264dsp_init(&p->h264dsp, 8, 1);
     return 0;
 }
 
diff --git a/libavcodec/h264_sei.c b/libavcodec/h264_sei.c
new file mode 100644
index 0000000000..d4eb9c0dab
--- /dev/null
+++ b/libavcodec/h264_sei.c
@@ -0,0 +1,522 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... SEI decoding
+ * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * H.264 / AVC / MPEG-4 part10 SEI decoding.
+ * @author Michael Niedermayer <michaelni@gmx.at>
+ */
+
+#include "avcodec.h"
+#include "get_bits.h"
+#include "golomb.h"
+#include "h264_ps.h"
+#include "h264_sei.h"
+#include "internal.h"
+
+#define AVERROR_PS_NOT_FOUND      FFERRTAG(0xF8,'?','P','S')
+
+static const uint8_t sei_num_clock_ts_table[9] = {
+    1, 1, 1, 2, 2, 3, 3, 2, 3
+};
+
+void ff_h264_sei_uninit(H264SEIContext *h)
+{
+    h->recovery_point.recovery_frame_cnt = -1;
+
+    h->picture_timing.dpb_output_delay  = 0;
+    h->picture_timing.cpb_removal_delay = -1;
+
+    h->picture_timing.present      = 0;
+    h->buffering_period.present    = 0;
+    h->frame_packing.present       = 0;
+    h->display_orientation.present = 0;
+    h->afd.present                 =  0;
+
+    av_buffer_unref(&h->a53_caption.buf_ref);
+}
+
+static int decode_picture_timing(H264SEIPictureTiming *h, GetBitContext *gb,
+                                 const H264ParamSets *ps, void *logctx)
+{
+    int i;
+    const SPS *sps = ps->sps;
+
+    for (i = 0; i<MAX_SPS_COUNT; i++)
+        if ((!sps || !sps->log2_max_frame_num) && ps->sps_list[i])
+            sps = (const SPS *)ps->sps_list[i]->data;
+
+    if (!sps) {
+        av_log(logctx, AV_LOG_ERROR, "SPS unavailable in decode_picture_timing\n");
+        return AVERROR_PS_NOT_FOUND;
+    }
+
+    if (sps->nal_hrd_parameters_present_flag ||
+        sps->vcl_hrd_parameters_present_flag) {
+        h->cpb_removal_delay = get_bits_long(gb, sps->cpb_removal_delay_length);
+        h->dpb_output_delay  = get_bits_long(gb, sps->dpb_output_delay_length);
+    }
+    if (sps->pic_struct_present_flag) {
+        unsigned int i, num_clock_ts;
+
+        h->pic_struct = get_bits(gb, 4);
+        h->ct_type    = 0;
+
+        if (h->pic_struct > H264_SEI_PIC_STRUCT_FRAME_TRIPLING)
+            return AVERROR_INVALIDDATA;
+
+        num_clock_ts = sei_num_clock_ts_table[h->pic_struct];
+        h->timecode_cnt = 0;
+        for (i = 0; i < num_clock_ts; i++) {
+            if (get_bits(gb, 1)) {                      /* clock_timestamp_flag */
+                H264SEITimeCode *tc = &h->timecode[h->timecode_cnt++];
+                unsigned int full_timestamp_flag;
+                unsigned int counting_type, cnt_dropped_flag;
+                h->ct_type |= 1 << get_bits(gb, 2);
+                skip_bits(gb, 1);                       /* nuit_field_based_flag */
+                counting_type = get_bits(gb, 5);        /* counting_type */
+                full_timestamp_flag = get_bits(gb, 1);
+                skip_bits(gb, 1);                       /* discontinuity_flag */
+                cnt_dropped_flag = get_bits(gb, 1);      /* cnt_dropped_flag */
+                if (cnt_dropped_flag && counting_type > 1 && counting_type < 7)
+                    tc->dropframe = 1;
+                tc->frame = get_bits(gb, 8);         /* n_frames */
+                if (full_timestamp_flag) {
+                    tc->full = 1;
+                    tc->seconds = get_bits(gb, 6); /* seconds_value 0..59 */
+                    tc->minutes = get_bits(gb, 6); /* minutes_value 0..59 */
+                    tc->hours = get_bits(gb, 5);   /* hours_value 0..23 */
+                } else {
+                    tc->seconds = tc->minutes = tc->hours = tc->full = 0;
+                    if (get_bits(gb, 1)) {             /* seconds_flag */
+                        tc->seconds = get_bits(gb, 6);
+                        if (get_bits(gb, 1)) {         /* minutes_flag */
+                            tc->minutes = get_bits(gb, 6);
+                            if (get_bits(gb, 1))       /* hours_flag */
+                                tc->hours = get_bits(gb, 5);
+                        }
+                    }
+                }
+
+                if (sps->time_offset_length > 0)
+                    skip_bits(gb,
+                              sps->time_offset_length); /* time_offset */
+            }
+        }
+
+        av_log(logctx, AV_LOG_DEBUG, "ct_type:%X pic_struct:%d\n",
+               h->ct_type, h->pic_struct);
+    }
+
+    h->present = 1;
+    return 0;
+}
+
+static int decode_registered_user_data_afd(H264SEIAFD *h, GetBitContext *gb, int size)
+{
+    int flag;
+
+    if (size-- < 1)
+        return AVERROR_INVALIDDATA;
+    skip_bits(gb, 1);               // 0
+    flag = get_bits(gb, 1);         // active_format_flag
+    skip_bits(gb, 6);               // reserved
+
+    if (flag) {
+        if (size-- < 1)
+            return AVERROR_INVALIDDATA;
+        skip_bits(gb, 4);           // reserved
+        h->active_format_description = get_bits(gb, 4);
+        h->present                   = 1;
+    }
+
+    return 0;
+}
+
+static int decode_registered_user_data_closed_caption(H264SEIA53Caption *h,
+                                                     GetBitContext *gb, void *logctx,
+                                                     int size)
+{
+    int flag;
+    int user_data_type_code;
+    int cc_count;
+
+    if (size < 3)
+        return AVERROR(EINVAL);
+
+    user_data_type_code = get_bits(gb, 8);
+    if (user_data_type_code == 0x3) {
+        skip_bits(gb, 1);           // reserved
+
+        flag = get_bits(gb, 1);     // process_cc_data_flag
+        if (flag) {
+            skip_bits(gb, 1);       // zero bit
+            cc_count = get_bits(gb, 5);
+            skip_bits(gb, 8);       // reserved
+            size -= 2;
+
+            if (cc_count && size >= cc_count * 3) {
+                int old_size = h->buf_ref ? h->buf_ref->size : 0;
+                const uint64_t new_size = (old_size + cc_count
+                                           * UINT64_C(3));
+                int i, ret;
+
+                if (new_size > INT_MAX)
+                    return AVERROR(EINVAL);
+
+                /* Allow merging of the cc data from two fields. */
+                ret = av_buffer_realloc(&h->buf_ref, new_size);
+                if (ret < 0)
+                    return ret;
+
+                /* Use of av_buffer_realloc assumes buffer is writeable */
+                for (i = 0; i < cc_count; i++) {
+                    h->buf_ref->data[old_size++] = get_bits(gb, 8);
+                    h->buf_ref->data[old_size++] = get_bits(gb, 8);
+                    h->buf_ref->data[old_size++] = get_bits(gb, 8);
+                }
+
+                skip_bits(gb, 8);   // marker_bits
+            }
+        }
+    } else {
+        int i;
+        for (i = 0; i < size - 1; i++)
+            skip_bits(gb, 8);
+    }
+
+    return 0;
+}
+
+static int decode_registered_user_data(H264SEIContext *h, GetBitContext *gb,
+                                       void *logctx, int size)
+{
+    uint32_t country_code;
+    uint32_t user_identifier;
+
+    if (size < 7)
+        return AVERROR_INVALIDDATA;
+    size -= 7;
+
+    country_code = get_bits(gb, 8); // itu_t_t35_country_code
+    if (country_code == 0xFF) {
+        skip_bits(gb, 8);           // itu_t_t35_country_code_extension_byte
+        size--;
+    }
+
+    /* itu_t_t35_payload_byte follows */
+    skip_bits(gb, 8);              // terminal provider code
+    skip_bits(gb, 8);              // terminal provider oriented code
+    user_identifier = get_bits_long(gb, 32);
+
+    switch (user_identifier) {
+        case MKBETAG('D', 'T', 'G', '1'):       // afd_data
+            return decode_registered_user_data_afd(&h->afd, gb, size);
+        case MKBETAG('G', 'A', '9', '4'):       // closed captions
+            return decode_registered_user_data_closed_caption(&h->a53_caption, gb,
+                                                              logctx, size);
+        default:
+            skip_bits(gb, size * 8);
+            break;
+    }
+
+    return 0;
+}
+
+static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,
+                                         void *logctx, int size)
+{
+    uint8_t *user_data;
+    int e, build, i;
+
+    if (size < 16 || size >= INT_MAX - 16)
+        return AVERROR_INVALIDDATA;
+
+    user_data = av_malloc(16 + size + 1);
+    if (!user_data)
+        return AVERROR(ENOMEM);
+
+    for (i = 0; i < size + 16; i++)
+        user_data[i] = get_bits(gb, 8);
+
+    user_data[i] = 0;
+    e = sscanf(user_data + 16, "x264 - core %d", &build);
+    if (e == 1 && build > 0)
+        h->x264_build = build;
+    if (e == 1 && build == 1 && !strncmp(user_data+16, "x264 - core 0000", 16))
+        h->x264_build = 67;
+
+    av_free(user_data);
+    return 0;
+}
+
+static int decode_recovery_point(H264SEIRecoveryPoint *h, GetBitContext *gb, void *logctx)
+{
+    unsigned recovery_frame_cnt = get_ue_golomb_long(gb);
+
+    if (recovery_frame_cnt >= (1<<MAX_LOG2_MAX_FRAME_NUM)) {
+        av_log(logctx, AV_LOG_ERROR, "recovery_frame_cnt %u is out of range\n", recovery_frame_cnt);
+        return AVERROR_INVALIDDATA;
+    }
+
+    h->recovery_frame_cnt = recovery_frame_cnt;
+    /* 1b exact_match_flag,
+     * 1b broken_link_flag,
+     * 2b changing_slice_group_idc */
+    skip_bits(gb, 4);
+
+    return 0;
+}
+
+static int decode_buffering_period(H264SEIBufferingPeriod *h, GetBitContext *gb,
+                                   const H264ParamSets *ps, void *logctx)
+{
+    unsigned int sps_id;
+    int sched_sel_idx;
+    const SPS *sps;
+
+    sps_id = get_ue_golomb_31(gb);
+    if (sps_id > 31 || !ps->sps_list[sps_id]) {
+        av_log(logctx, AV_LOG_ERROR,
+               "non-existing SPS %d referenced in buffering period\n", sps_id);
+        return sps_id > 31 ? AVERROR_INVALIDDATA : AVERROR_PS_NOT_FOUND;
+    }
+    sps = (const SPS*)ps->sps_list[sps_id]->data;
+
+    // NOTE: This is really so duplicated in the standard... See H.264, D.1.1
+    if (sps->nal_hrd_parameters_present_flag) {
+        for (sched_sel_idx = 0; sched_sel_idx < sps->cpb_cnt; sched_sel_idx++) {
+            h->initial_cpb_removal_delay[sched_sel_idx] =
+                get_bits_long(gb, sps->initial_cpb_removal_delay_length);
+            // initial_cpb_removal_delay_offset
+            skip_bits(gb, sps->initial_cpb_removal_delay_length);
+        }
+    }
+    if (sps->vcl_hrd_parameters_present_flag) {
+        for (sched_sel_idx = 0; sched_sel_idx < sps->cpb_cnt; sched_sel_idx++) {
+            h->initial_cpb_removal_delay[sched_sel_idx] =
+                get_bits_long(gb, sps->initial_cpb_removal_delay_length);
+            // initial_cpb_removal_delay_offset
+            skip_bits(gb, sps->initial_cpb_removal_delay_length);
+        }
+    }
+
+    h->present = 1;
+    return 0;
+}
+
+static int decode_frame_packing_arrangement(H264SEIFramePacking *h,
+                                            GetBitContext *gb)
+{
+    h->arrangement_id          = get_ue_golomb_long(gb);
+    h->arrangement_cancel_flag = get_bits1(gb);
+    h->present = !h->arrangement_cancel_flag;
+
+    if (h->present) {
+        h->arrangement_type = get_bits(gb, 7);
+        h->quincunx_sampling_flag         = get_bits1(gb);
+        h->content_interpretation_type    = get_bits(gb, 6);
+
+        // spatial_flipping_flag, frame0_flipped_flag, field_views_flag
+        skip_bits(gb, 3);
+        h->current_frame_is_frame0_flag = get_bits1(gb);
+        // frame0_self_contained_flag, frame1_self_contained_flag
+        skip_bits(gb, 2);
+
+        if (!h->quincunx_sampling_flag && h->arrangement_type != 5)
+            skip_bits(gb, 16);      // frame[01]_grid_position_[xy]
+        skip_bits(gb, 8);           // frame_packing_arrangement_reserved_byte
+        h->arrangement_repetition_period = get_ue_golomb_long(gb);
+    }
+    skip_bits1(gb);                 // frame_packing_arrangement_extension_flag
+
+    return 0;
+}
+
+static int decode_display_orientation(H264SEIDisplayOrientation *h,
+                                      GetBitContext *gb)
+{
+    h->present = !get_bits1(gb);
+
+    if (h->present) {
+        h->hflip = get_bits1(gb);     // hor_flip
+        h->vflip = get_bits1(gb);     // ver_flip
+
+        h->anticlockwise_rotation = get_bits(gb, 16);
+        get_ue_golomb_long(gb);       // display_orientation_repetition_period
+        skip_bits1(gb);               // display_orientation_extension_flag
+    }
+
+    return 0;
+}
+
+static int decode_green_metadata(H264SEIGreenMetaData *h, GetBitContext *gb)
+{
+    h->green_metadata_type = get_bits(gb, 8);
+
+    if (h->green_metadata_type == 0) {
+        h->period_type = get_bits(gb, 8);
+
+        if (h->period_type == 2)
+            h->num_seconds = get_bits(gb, 16);
+        else if (h->period_type == 3)
+            h->num_pictures = get_bits(gb, 16);
+
+        h->percent_non_zero_macroblocks            = get_bits(gb, 8);
+        h->percent_intra_coded_macroblocks         = get_bits(gb, 8);
+        h->percent_six_tap_filtering               = get_bits(gb, 8);
+        h->percent_alpha_point_deblocking_instance = get_bits(gb, 8);
+
+    } else if (h->green_metadata_type == 1) {
+        h->xsd_metric_type  = get_bits(gb, 8);
+        h->xsd_metric_value = get_bits(gb, 16);
+    }
+
+    return 0;
+}
+
+static int decode_alternative_transfer(H264SEIAlternativeTransfer *h,
+                                       GetBitContext *gb)
+{
+    h->present = 1;
+    h->preferred_transfer_characteristics = get_bits(gb, 8);
+    return 0;
+}
+
+int ff_h264_sei_decode(H264SEIContext *h, GetBitContext *gb,
+                       const H264ParamSets *ps, void *logctx)
+{
+    int master_ret = 0;
+
+    while (get_bits_left(gb) > 16 && show_bits(gb, 16)) {
+        int type = 0;
+        unsigned size = 0;
+        unsigned next;
+        int ret  = 0;
+
+        do {
+            if (get_bits_left(gb) < 8)
+                return AVERROR_INVALIDDATA;
+            type += show_bits(gb, 8);
+        } while (get_bits(gb, 8) == 255);
+
+        do {
+            if (get_bits_left(gb) < 8)
+                return AVERROR_INVALIDDATA;
+            size += show_bits(gb, 8);
+        } while (get_bits(gb, 8) == 255);
+
+        if (size > get_bits_left(gb) / 8) {
+            av_log(logctx, AV_LOG_ERROR, "SEI type %d size %d truncated at %d\n",
+                   type, 8*size, get_bits_left(gb));
+            return AVERROR_INVALIDDATA;
+        }
+        next = get_bits_count(gb) + 8 * size;
+
+        switch (type) {
+        case H264_SEI_TYPE_PIC_TIMING: // Picture timing SEI
+            ret = decode_picture_timing(&h->picture_timing, gb, ps, logctx);
+            break;
+        case H264_SEI_TYPE_USER_DATA_REGISTERED:
+            ret = decode_registered_user_data(h, gb, logctx, size);
+            break;
+        case H264_SEI_TYPE_USER_DATA_UNREGISTERED:
+            ret = decode_unregistered_user_data(&h->unregistered, gb, logctx, size);
+            break;
+        case H264_SEI_TYPE_RECOVERY_POINT:
+            ret = decode_recovery_point(&h->recovery_point, gb, logctx);
+            break;
+        case H264_SEI_TYPE_BUFFERING_PERIOD:
+            ret = decode_buffering_period(&h->buffering_period, gb, ps, logctx);
+            break;
+        case H264_SEI_TYPE_FRAME_PACKING:
+            ret = decode_frame_packing_arrangement(&h->frame_packing, gb);
+            break;
+        case H264_SEI_TYPE_DISPLAY_ORIENTATION:
+            ret = decode_display_orientation(&h->display_orientation, gb);
+            break;
+        case H264_SEI_TYPE_GREEN_METADATA:
+            ret = decode_green_metadata(&h->green_metadata, gb);
+            break;
+        case H264_SEI_TYPE_ALTERNATIVE_TRANSFER:
+            ret = decode_alternative_transfer(&h->alternative_transfer, gb);
+            break;
+        default:
+            av_log(logctx, AV_LOG_DEBUG, "unknown SEI type %d\n", type);
+        }
+        if (ret < 0 && ret != AVERROR_PS_NOT_FOUND)
+            return ret;
+        if (ret < 0)
+            master_ret = ret;
+
+        skip_bits_long(gb, next - get_bits_count(gb));
+
+        // FIXME check bits here
+        align_get_bits(gb);
+    }
+
+    return master_ret;
+}
+
+const char *ff_h264_sei_stereo_mode(const H264SEIFramePacking *h)
+{
+    if (h->arrangement_cancel_flag == 0) {
+        switch (h->arrangement_type) {
+            case H264_SEI_FPA_TYPE_CHECKERBOARD:
+                if (h->content_interpretation_type == 2)
+                    return "checkerboard_rl";
+                else
+                    return "checkerboard_lr";
+            case H264_SEI_FPA_TYPE_INTERLEAVE_COLUMN:
+                if (h->content_interpretation_type == 2)
+                    return "col_interleaved_rl";
+                else
+                    return "col_interleaved_lr";
+            case H264_SEI_FPA_TYPE_INTERLEAVE_ROW:
+                if (h->content_interpretation_type == 2)
+                    return "row_interleaved_rl";
+                else
+                    return "row_interleaved_lr";
+            case H264_SEI_FPA_TYPE_SIDE_BY_SIDE:
+                if (h->content_interpretation_type == 2)
+                    return "right_left";
+                else
+                    return "left_right";
+            case H264_SEI_FPA_TYPE_TOP_BOTTOM:
+                if (h->content_interpretation_type == 2)
+                    return "bottom_top";
+                else
+                    return "top_bottom";
+            case H264_SEI_FPA_TYPE_INTERLEAVE_TEMPORAL:
+                if (h->content_interpretation_type == 2)
+                    return "block_rl";
+                else
+                    return "block_lr";
+            case H264_SEI_FPA_TYPE_2D:
+            default:
+                return "mono";
+        }
+    } else if (h->arrangement_cancel_flag == 1) {
+        return "mono";
+    } else {
+        return NULL;
+    }
+}
diff --git a/libavcodec/h264_sei.h b/libavcodec/h264_sei.h
new file mode 100644
index 0000000000..a75c3aa175
--- /dev/null
+++ b/libavcodec/h264_sei.h
@@ -0,0 +1,205 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_H264_SEI_H
+#define AVCODEC_H264_SEI_H
+
+#include "get_bits.h"
+
+/**
+ * SEI message types
+ */
+typedef enum {
+    H264_SEI_TYPE_BUFFERING_PERIOD       = 0,   ///< buffering period (H.264, D.1.1)
+    H264_SEI_TYPE_PIC_TIMING             = 1,   ///< picture timing
+    H264_SEI_TYPE_PAN_SCAN_RECT          = 2,   ///< pan-scan rectangle
+    H264_SEI_TYPE_FILLER_PAYLOAD         = 3,   ///< filler data
+    H264_SEI_TYPE_USER_DATA_REGISTERED   = 4,   ///< registered user data as specified by Rec. ITU-T T.35
+    H264_SEI_TYPE_USER_DATA_UNREGISTERED = 5,   ///< unregistered user data
+    H264_SEI_TYPE_RECOVERY_POINT         = 6,   ///< recovery point (frame # to decoder sync)
+    H264_SEI_TYPE_FRAME_PACKING          = 45,  ///< frame packing arrangement
+    H264_SEI_TYPE_DISPLAY_ORIENTATION    = 47,  ///< display orientation
+    H264_SEI_TYPE_GREEN_METADATA         = 56,  ///< GreenMPEG information
+    H264_SEI_TYPE_MASTERING_DISPLAY_COLOUR_VOLUME = 137,  ///< mastering display properties
+    H264_SEI_TYPE_ALTERNATIVE_TRANSFER   = 147, ///< alternative transfer
+} H264_SEI_Type;
+
+/**
+ * pic_struct in picture timing SEI message
+ */
+typedef enum {
+    H264_SEI_PIC_STRUCT_FRAME             = 0, ///<  0: %frame
+    H264_SEI_PIC_STRUCT_TOP_FIELD         = 1, ///<  1: top field
+    H264_SEI_PIC_STRUCT_BOTTOM_FIELD      = 2, ///<  2: bottom field
+    H264_SEI_PIC_STRUCT_TOP_BOTTOM        = 3, ///<  3: top field, bottom field, in that order
+    H264_SEI_PIC_STRUCT_BOTTOM_TOP        = 4, ///<  4: bottom field, top field, in that order
+    H264_SEI_PIC_STRUCT_TOP_BOTTOM_TOP    = 5, ///<  5: top field, bottom field, top field repeated, in that order
+    H264_SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM = 6, ///<  6: bottom field, top field, bottom field repeated, in that order
+    H264_SEI_PIC_STRUCT_FRAME_DOUBLING    = 7, ///<  7: %frame doubling
+    H264_SEI_PIC_STRUCT_FRAME_TRIPLING    = 8  ///<  8: %frame tripling
+} H264_SEI_PicStructType;
+
+/**
+ * frame_packing_arrangement types
+ */
+typedef enum {
+    H264_SEI_FPA_TYPE_CHECKERBOARD        = 0,
+    H264_SEI_FPA_TYPE_INTERLEAVE_COLUMN   = 1,
+    H264_SEI_FPA_TYPE_INTERLEAVE_ROW      = 2,
+    H264_SEI_FPA_TYPE_SIDE_BY_SIDE        = 3,
+    H264_SEI_FPA_TYPE_TOP_BOTTOM          = 4,
+    H264_SEI_FPA_TYPE_INTERLEAVE_TEMPORAL = 5,
+    H264_SEI_FPA_TYPE_2D                  = 6,
+} H264_SEI_FpaType;
+
+typedef struct H264SEITimeCode {
+    /* When not continuously receiving full timecodes, we have to reference
+       the previous timecode received */
+    int full;
+    int frame;
+    int seconds;
+    int minutes;
+    int hours;
+    int dropframe;
+} H264SEITimeCode;
+
+typedef struct H264SEIPictureTiming {
+    int present;
+    H264_SEI_PicStructType pic_struct;
+
+    /**
+     * Bit set of clock types for fields/frames in picture timing SEI message.
+     * For each found ct_type, appropriate bit is set (e.g., bit 1 for
+     * interlaced).
+     */
+    int ct_type;
+
+    /**
+     * dpb_output_delay in picture timing SEI message, see H.264 C.2.2
+     */
+    int dpb_output_delay;
+
+    /**
+     * cpb_removal_delay in picture timing SEI message, see H.264 C.1.2
+     */
+    int cpb_removal_delay;
+
+    /**
+     * Maximum three timecodes in a pic_timing SEI.
+     */
+    H264SEITimeCode timecode[3];
+
+    /**
+     * Number of timecode in use
+     */
+    int timecode_cnt;
+} H264SEIPictureTiming;
+
+typedef struct H264SEIAFD {
+    int present;
+    uint8_t active_format_description;
+} H264SEIAFD;
+
+typedef struct H264SEIA53Caption {
+    AVBufferRef *buf_ref;
+} H264SEIA53Caption;
+
+typedef struct H264SEIUnregistered {
+    int x264_build;
+} H264SEIUnregistered;
+
+typedef struct H264SEIRecoveryPoint {
+    /**
+     * recovery_frame_cnt
+     *
+     * Set to -1 if no recovery point SEI message found or to number of frames
+     * before playback synchronizes. Frames having recovery point are key
+     * frames.
+     */
+    int recovery_frame_cnt;
+} H264SEIRecoveryPoint;
+
+typedef struct H264SEIBufferingPeriod {
+    int present;   ///< Buffering period SEI flag
+    int initial_cpb_removal_delay[32];  ///< Initial timestamps for CPBs
+} H264SEIBufferingPeriod;
+
+typedef struct H264SEIFramePacking {
+    int present;
+    int arrangement_id;
+    int arrangement_cancel_flag;  ///< is previous arrangement canceled, -1 if never received
+    H264_SEI_FpaType arrangement_type;
+    int arrangement_repetition_period;
+    int content_interpretation_type;
+    int quincunx_sampling_flag;
+    int current_frame_is_frame0_flag;
+} H264SEIFramePacking;
+
+typedef struct H264SEIDisplayOrientation {
+    int present;
+    int anticlockwise_rotation;
+    int hflip, vflip;
+} H264SEIDisplayOrientation;
+
+typedef struct H264SEIGreenMetaData {
+    uint8_t green_metadata_type;
+    uint8_t period_type;
+    uint16_t num_seconds;
+    uint16_t num_pictures;
+    uint8_t percent_non_zero_macroblocks;
+    uint8_t percent_intra_coded_macroblocks;
+    uint8_t percent_six_tap_filtering;
+    uint8_t percent_alpha_point_deblocking_instance;
+    uint8_t xsd_metric_type;
+    uint16_t xsd_metric_value;
+} H264SEIGreenMetaData;
+
+typedef struct H264SEIAlternativeTransfer {
+    int present;
+    int preferred_transfer_characteristics;
+} H264SEIAlternativeTransfer;
+
+typedef struct H264SEIContext {
+    H264SEIPictureTiming picture_timing;
+    H264SEIAFD afd;
+    H264SEIA53Caption a53_caption;
+    H264SEIUnregistered unregistered;
+    H264SEIRecoveryPoint recovery_point;
+    H264SEIBufferingPeriod buffering_period;
+    H264SEIFramePacking frame_packing;
+    H264SEIDisplayOrientation display_orientation;
+    H264SEIGreenMetaData green_metadata;
+    H264SEIAlternativeTransfer alternative_transfer;
+} H264SEIContext;
+
+struct H264ParamSets;
+
+int ff_h264_sei_decode(H264SEIContext *h, GetBitContext *gb,
+                       const struct H264ParamSets *ps, void *logctx);
+
+/**
+ * Reset SEI values at the beginning of the frame.
+ */
+void ff_h264_sei_uninit(H264SEIContext *h);
+
+/**
+ * Get stereo_mode string from the h264 frame_packing_arrangement
+ */
+const char *ff_h264_sei_stereo_mode(const H264SEIFramePacking *h);
+
+#endif /* AVCODEC_H264_SEI_H */
diff --git a/libavcodec/h264data.c b/libavcodec/h264data.c
new file mode 100644
index 0000000000..a4c6d93cf0
--- /dev/null
+++ b/libavcodec/h264data.c
@@ -0,0 +1,232 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief
+ *     H.264 / AVC / MPEG-4 part10 codec data table
+ * @author Michael Niedermayer <michaelni@gmx.at>
+ */
+
+#include <stdint.h>
+
+#include "libavutil/avutil.h"
+
+#include "avcodec.h"
+#include "h264dec.h"
+#include "h264data.h"
+
+const uint8_t ff_h264_golomb_to_pict_type[5] = {
+    AV_PICTURE_TYPE_P, AV_PICTURE_TYPE_B, AV_PICTURE_TYPE_I,
+    AV_PICTURE_TYPE_SP, AV_PICTURE_TYPE_SI
+};
+
+const uint8_t ff_h264_golomb_to_intra4x4_cbp[48] = {
+    47, 31, 15, 0,  23, 27, 29, 30, 7,  11, 13, 14, 39, 43, 45, 46,
+    16, 3,  5,  10, 12, 19, 21, 26, 28, 35, 37, 42, 44, 1,  2,  4,
+    8,  17, 18, 20, 24, 6,  9,  22, 25, 32, 33, 34, 36, 40, 38, 41
+};
+
+const uint8_t ff_h264_golomb_to_inter_cbp[48] = {
+    0,  16, 1,  2,  4,  8,  32, 3,  5,  10, 12, 15, 47, 7,  11, 13,
+    14, 6,  9,  31, 35, 37, 42, 44, 33, 34, 36, 40, 39, 43, 45, 46,
+    17, 18, 20, 24, 19, 21, 26, 28, 23, 27, 29, 30, 22, 25, 38, 41
+};
+
+const uint8_t ff_h264_chroma_dc_scan[4] = {
+    (0 + 0 * 2) * 16, (1 + 0 * 2) * 16,
+    (0 + 1 * 2) * 16, (1 + 1 * 2) * 16,
+};
+
+const uint8_t ff_h264_chroma422_dc_scan[8] = {
+    (0 + 0 * 2) * 16, (0 + 1 * 2) * 16,
+    (1 + 0 * 2) * 16, (0 + 2 * 2) * 16,
+    (0 + 3 * 2) * 16, (1 + 1 * 2) * 16,
+    (1 + 2 * 2) * 16, (1 + 3 * 2) * 16,
+};
+
+const IMbInfo ff_h264_i_mb_type_info[26] = {
+    { MB_TYPE_INTRA4x4,  -1,  -1 },
+    { MB_TYPE_INTRA16x16, 2,   0 },
+    { MB_TYPE_INTRA16x16, 1,   0 },
+    { MB_TYPE_INTRA16x16, 0,   0 },
+    { MB_TYPE_INTRA16x16, 3,   0 },
+    { MB_TYPE_INTRA16x16, 2,  16 },
+    { MB_TYPE_INTRA16x16, 1,  16 },
+    { MB_TYPE_INTRA16x16, 0,  16 },
+    { MB_TYPE_INTRA16x16, 3,  16 },
+    { MB_TYPE_INTRA16x16, 2,  32 },
+    { MB_TYPE_INTRA16x16, 1,  32 },
+    { MB_TYPE_INTRA16x16, 0,  32 },
+    { MB_TYPE_INTRA16x16, 3,  32 },
+    { MB_TYPE_INTRA16x16, 2,  15 +  0 },
+    { MB_TYPE_INTRA16x16, 1,  15 +  0 },
+    { MB_TYPE_INTRA16x16, 0,  15 +  0 },
+    { MB_TYPE_INTRA16x16, 3,  15 +  0 },
+    { MB_TYPE_INTRA16x16, 2,  15 + 16 },
+    { MB_TYPE_INTRA16x16, 1,  15 + 16 },
+    { MB_TYPE_INTRA16x16, 0,  15 + 16 },
+    { MB_TYPE_INTRA16x16, 3,  15 + 16 },
+    { MB_TYPE_INTRA16x16, 2,  15 + 32 },
+    { MB_TYPE_INTRA16x16, 1,  15 + 32 },
+    { MB_TYPE_INTRA16x16, 0,  15 + 32 },
+    { MB_TYPE_INTRA16x16, 3,  15 + 32 },
+    { MB_TYPE_INTRA_PCM,  -1, -1 },
+};
+
+const PMbInfo ff_h264_p_mb_type_info[5] = {
+    { MB_TYPE_16x16 | MB_TYPE_P0L0,                               1 },
+    { MB_TYPE_16x8  | MB_TYPE_P0L0 | MB_TYPE_P1L0,                2 },
+    { MB_TYPE_8x16  | MB_TYPE_P0L0 | MB_TYPE_P1L0,                2 },
+    { MB_TYPE_8x8   | MB_TYPE_P0L0 | MB_TYPE_P1L0,                4 },
+    { MB_TYPE_8x8   | MB_TYPE_P0L0 | MB_TYPE_P1L0 | MB_TYPE_REF0, 4 },
+};
+
+const PMbInfo ff_h264_p_sub_mb_type_info[4] = {
+    { MB_TYPE_16x16 | MB_TYPE_P0L0, 1 },
+    { MB_TYPE_16x8  | MB_TYPE_P0L0, 2 },
+    { MB_TYPE_8x16  | MB_TYPE_P0L0, 2 },
+    { MB_TYPE_8x8   | MB_TYPE_P0L0, 4 },
+};
+
+const PMbInfo ff_h264_b_mb_type_info[23] = {
+    { MB_TYPE_DIRECT2 | MB_TYPE_L0L1,                                              1, },
+    { MB_TYPE_16x16   | MB_TYPE_P0L0,                                              1, },
+    { MB_TYPE_16x16   | MB_TYPE_P0L1,                                              1, },
+    { MB_TYPE_16x16   | MB_TYPE_P0L0 | MB_TYPE_P0L1,                               1, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L0 | MB_TYPE_P1L0,                               2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L0 | MB_TYPE_P1L0,                               2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L1 | MB_TYPE_P1L1,                               2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L1 | MB_TYPE_P1L1,                               2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L0 | MB_TYPE_P1L1,                               2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L0 | MB_TYPE_P1L1,                               2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L1 | MB_TYPE_P1L0,                               2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L1 | MB_TYPE_P1L0,                               2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L0 | MB_TYPE_P1L0 | MB_TYPE_P1L1,                2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L0 | MB_TYPE_P1L0 | MB_TYPE_P1L1,                2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1,                2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1,                2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0,                2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0,                2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L1,                2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L1,                2, },
+    { MB_TYPE_16x8    | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1, 2, },
+    { MB_TYPE_8x16    | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1, 2, },
+    { MB_TYPE_8x8     | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1, 4, },
+};
+
+const PMbInfo ff_h264_b_sub_mb_type_info[13] = {
+    { MB_TYPE_DIRECT2,                                                           1, },
+    { MB_TYPE_16x16 | MB_TYPE_P0L0,                                              1, },
+    { MB_TYPE_16x16 | MB_TYPE_P0L1,                                              1, },
+    { MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1,                               1, },
+    { MB_TYPE_16x8  | MB_TYPE_P0L0 | MB_TYPE_P1L0,                               2, },
+    { MB_TYPE_8x16  | MB_TYPE_P0L0 | MB_TYPE_P1L0,                               2, },
+    { MB_TYPE_16x8  | MB_TYPE_P0L1 | MB_TYPE_P1L1,                               2, },
+    { MB_TYPE_8x16  | MB_TYPE_P0L1 | MB_TYPE_P1L1,                               2, },
+    { MB_TYPE_16x8  | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1, 2, },
+    { MB_TYPE_8x16  | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1, 2, },
+    { MB_TYPE_8x8   | MB_TYPE_P0L0 | MB_TYPE_P1L0,                               4, },
+    { MB_TYPE_8x8   | MB_TYPE_P0L1 | MB_TYPE_P1L1,                               4, },
+    { MB_TYPE_8x8   | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_P1L0 | MB_TYPE_P1L1, 4, },
+};
+
+const uint8_t ff_h264_dequant4_coeff_init[6][3] = {
+    { 10, 13, 16 },
+    { 11, 14, 18 },
+    { 13, 16, 20 },
+    { 14, 18, 23 },
+    { 16, 20, 25 },
+    { 18, 23, 29 },
+};
+
+const uint8_t ff_h264_dequant8_coeff_init_scan[16] = {
+    0, 3, 4, 3, 3, 1, 5, 1, 4, 5, 2, 5, 3, 1, 5, 1
+};
+
+const uint8_t ff_h264_dequant8_coeff_init[6][6] = {
+    { 20, 18, 32, 19, 25, 24 },
+    { 22, 19, 35, 21, 28, 26 },
+    { 26, 23, 42, 24, 33, 31 },
+    { 28, 25, 45, 26, 35, 33 },
+    { 32, 28, 51, 30, 40, 38 },
+    { 36, 32, 58, 34, 46, 43 },
+};
+
+const uint8_t ff_h264_quant_rem6[QP_MAX_NUM + 1] = {
+    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
+    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
+    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3,
+};
+
+const uint8_t ff_h264_quant_div6[QP_MAX_NUM + 1] = {
+    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,
+    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,
+    7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,
+   10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,
+   14,14,14,14,
+};
+
+#define QP(qP, depth) ((qP) + 6 * ((depth) - 8))
+
+#define CHROMA_QP_TABLE_END(d)                                          \
+    QP(0,  d), QP(1,  d), QP(2,  d), QP(3,  d), QP(4,  d), QP(5,  d),   \
+    QP(6,  d), QP(7,  d), QP(8,  d), QP(9,  d), QP(10, d), QP(11, d),   \
+    QP(12, d), QP(13, d), QP(14, d), QP(15, d), QP(16, d), QP(17, d),   \
+    QP(18, d), QP(19, d), QP(20, d), QP(21, d), QP(22, d), QP(23, d),   \
+    QP(24, d), QP(25, d), QP(26, d), QP(27, d), QP(28, d), QP(29, d),   \
+    QP(29, d), QP(30, d), QP(31, d), QP(32, d), QP(32, d), QP(33, d),   \
+    QP(34, d), QP(34, d), QP(35, d), QP(35, d), QP(36, d), QP(36, d),   \
+    QP(37, d), QP(37, d), QP(37, d), QP(38, d), QP(38, d), QP(38, d),   \
+    QP(39, d), QP(39, d), QP(39, d), QP(39, d)
+
+const uint8_t ff_h264_chroma_qp[7][QP_MAX_NUM + 1] = {
+    { CHROMA_QP_TABLE_END(8) },
+    { 0, 1, 2, 3, 4, 5,
+      CHROMA_QP_TABLE_END(9) },
+    { 0, 1, 2, 3,  4,  5,
+      6, 7, 8, 9, 10, 11,
+      CHROMA_QP_TABLE_END(10) },
+    { 0,  1, 2, 3,  4,  5,
+      6,  7, 8, 9, 10, 11,
+      12,13,14,15, 16, 17,
+      CHROMA_QP_TABLE_END(11) },
+    { 0,  1, 2, 3,  4,  5,
+      6,  7, 8, 9, 10, 11,
+      12,13,14,15, 16, 17,
+      18,19,20,21, 22, 23,
+      CHROMA_QP_TABLE_END(12) },
+    { 0,  1, 2, 3,  4,  5,
+      6,  7, 8, 9, 10, 11,
+      12,13,14,15, 16, 17,
+      18,19,20,21, 22, 23,
+      24,25,26,27, 28, 29,
+      CHROMA_QP_TABLE_END(13) },
+    { 0,  1, 2, 3,  4,  5,
+      6,  7, 8, 9, 10, 11,
+      12,13,14,15, 16, 17,
+      18,19,20,21, 22, 23,
+      24,25,26,27, 28, 29,
+      30,31,32,33, 34, 35,
+      CHROMA_QP_TABLE_END(14) },
+};
diff --git a/libavcodec/h264data.h b/libavcodec/h264data.h
new file mode 100644
index 0000000000..2968b08b7e
--- /dev/null
+++ b/libavcodec/h264data.h
@@ -0,0 +1,79 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_H264DATA_H
+#define AVCODEC_H264DATA_H
+
+#include <stdint.h>
+
+#include "h264dec.h"
+
+extern const uint8_t ff_h264_golomb_to_pict_type[5];
+extern const uint8_t ff_h264_golomb_to_intra4x4_cbp[48];
+extern const uint8_t ff_h264_golomb_to_inter_cbp[48];
+
+extern const uint8_t ff_h264_chroma_dc_scan[4];
+extern const uint8_t ff_h264_chroma422_dc_scan[8];
+
+typedef struct IMbInfo {
+    uint16_t type;
+    uint8_t pred_mode;
+    uint8_t cbp;
+} IMbInfo;
+
+extern const IMbInfo ff_h264_i_mb_type_info[26];
+
+typedef struct PMbInfo {
+    uint16_t type;
+    uint8_t partition_count;
+} PMbInfo;
+
+extern const PMbInfo ff_h264_p_mb_type_info[5];
+extern const PMbInfo ff_h264_p_sub_mb_type_info[4];
+extern const PMbInfo ff_h264_b_mb_type_info[23];
+extern const PMbInfo ff_h264_b_sub_mb_type_info[13];
+
+static const AVRational ff_h264_pixel_aspect[17] = {
+    {   0,  1 },
+    {   1,  1 },
+    {  12, 11 },
+    {  10, 11 },
+    {  16, 11 },
+    {  40, 33 },
+    {  24, 11 },
+    {  20, 11 },
+    {  32, 11 },
+    {  80, 33 },
+    {  18, 11 },
+    {  15, 11 },
+    {  64, 33 },
+    { 160, 99 },
+    {   4,  3 },
+    {   3,  2 },
+    {   2,  1 },
+};
+
+extern const uint8_t ff_h264_dequant4_coeff_init[6][3];
+extern const uint8_t ff_h264_dequant8_coeff_init_scan[16];
+extern const uint8_t ff_h264_dequant8_coeff_init[6][6];
+extern const uint8_t ff_h264_quant_rem6[QP_MAX_NUM + 1];
+extern const uint8_t ff_h264_quant_div6[QP_MAX_NUM + 1];
+
+extern const uint8_t ff_h264_chroma_qp[7][QP_MAX_NUM + 1];
+
+#endif /* AVCODEC_H264DATA_H */
diff --git a/libavcodec/h264dec.h b/libavcodec/h264dec.h
new file mode 100644
index 0000000000..1d9723260d
--- /dev/null
+++ b/libavcodec/h264dec.h
@@ -0,0 +1,854 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * H.264 / AVC / MPEG-4 part10 codec.
+ * @author Michael Niedermayer <michaelni@gmx.at>
+ */
+
+#ifndef AVCODEC_H264DEC_H
+#define AVCODEC_H264DEC_H
+
+#include "libavutil/buffer.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/thread.h"
+
+#include "cabac.h"
+#include "error_resilience.h"
+#include "h264_parse.h"
+#include "h264_ps.h"
+#include "h264_sei.h"
+#include "h2645_parse.h"
+#include "h264chroma.h"
+#include "h264dsp.h"
+#include "h264pred.h"
+#include "h264qpel.h"
+#include "internal.h"
+#include "mpegutils.h"
+#include "parser.h"
+#include "qpeldsp.h"
+#include "rectangle.h"
+#include "videodsp.h"
+
+#define H264_MAX_PICTURE_COUNT 36
+
+#define MAX_MMCO_COUNT         66
+
+#define MAX_DELAYED_PIC_COUNT  16
+
+/* Compiling in interlaced support reduces the speed
+ * of progressive decoding by about 2%. */
+#define ALLOW_INTERLACE
+
+#define FMO 0
+
+/**
+ * The maximum number of slices supported by the decoder.
+ * must be a power of 2
+ */
+#define MAX_SLICES 32
+
+#ifdef ALLOW_INTERLACE
+#define MB_MBAFF(h)    (h)->mb_mbaff
+#define MB_FIELD(sl)  (sl)->mb_field_decoding_flag
+#define FRAME_MBAFF(h) (h)->mb_aff_frame
+#define FIELD_PICTURE(h) ((h)->picture_structure != PICT_FRAME)
+#define LEFT_MBS 2
+#define LTOP     0
+#define LBOT     1
+#define LEFT(i)  (i)
+#else
+#define MB_MBAFF(h)      0
+#define MB_FIELD(sl)     0
+#define FRAME_MBAFF(h)   0
+#define FIELD_PICTURE(h) 0
+#undef  IS_INTERLACED
+#define IS_INTERLACED(mb_type) 0
+#define LEFT_MBS 1
+#define LTOP     0
+#define LBOT     0
+#define LEFT(i)  0
+#endif
+#define FIELD_OR_MBAFF_PICTURE(h) (FRAME_MBAFF(h) || FIELD_PICTURE(h))
+
+#ifndef CABAC
+#define CABAC(h) (h)->ps.pps->cabac
+#endif
+
+#define CHROMA(h)    ((h)->ps.sps->chroma_format_idc)
+#define CHROMA422(h) ((h)->ps.sps->chroma_format_idc == 2)
+#define CHROMA444(h) ((h)->ps.sps->chroma_format_idc == 3)
+
+#define MB_TYPE_REF0       MB_TYPE_ACPRED // dirty but it fits in 16 bit
+#define MB_TYPE_8x8DCT     0x01000000
+#define IS_REF0(a)         ((a) & MB_TYPE_REF0)
+#define IS_8x8DCT(a)       ((a) & MB_TYPE_8x8DCT)
+
+/**
+ * Memory management control operation opcode.
+ */
+typedef enum MMCOOpcode {
+    MMCO_END = 0,
+    MMCO_SHORT2UNUSED,
+    MMCO_LONG2UNUSED,
+    MMCO_SHORT2LONG,
+    MMCO_SET_MAX_LONG,
+    MMCO_RESET,
+    MMCO_LONG,
+} MMCOOpcode;
+
+/**
+ * Memory management control operation.
+ */
+typedef struct MMCO {
+    MMCOOpcode opcode;
+    int short_pic_num;  ///< pic_num without wrapping (pic_num & max_pic_num)
+    int long_arg;       ///< index, pic_num, or num long refs depending on opcode
+} MMCO;
+
+typedef struct H264Picture {
+    AVFrame *f;
+    ThreadFrame tf;
+
+    AVBufferRef *qscale_table_buf;
+    int8_t *qscale_table;
+
+    AVBufferRef *motion_val_buf[2];
+    int16_t (*motion_val[2])[2];
+
+    AVBufferRef *mb_type_buf;
+    uint32_t *mb_type;
+
+    AVBufferRef *hwaccel_priv_buf;
+    void *hwaccel_picture_private; ///< hardware accelerator private data
+
+    AVBufferRef *ref_index_buf[2];
+    int8_t *ref_index[2];
+
+    int field_poc[2];       ///< top/bottom POC
+    int poc;                ///< frame POC
+    int frame_num;          ///< frame_num (raw frame_num from slice header)
+    int mmco_reset;         /**< MMCO_RESET set this 1. Reordering code must
+                                 not mix pictures before and after MMCO_RESET. */
+    int pic_id;             /**< pic_num (short -> no wrap version of pic_num,
+                                 pic_num & max_pic_num; long -> long_pic_num) */
+    int long_ref;           ///< 1->long term reference 0->short term reference
+    int ref_poc[2][2][32];  ///< POCs of the frames/fields used as reference (FIXME need per slice)
+    int ref_count[2][2];    ///< number of entries in ref_poc         (FIXME need per slice)
+    int mbaff;              ///< 1 -> MBAFF frame 0-> not MBAFF
+    int field_picture;      ///< whether or not picture was encoded in separate fields
+
+    int reference;
+    int recovered;          ///< picture at IDR or recovery point + recovery count
+    int invalid_gap;
+    int sei_recovery_frame_cnt;
+} H264Picture;
+
+typedef struct H264Ref {
+    uint8_t *data[3];
+    int linesize[3];
+
+    int reference;
+    int poc;
+    int pic_id;
+
+    H264Picture *parent;
+} H264Ref;
+
+typedef struct H264SliceContext {
+    struct H264Context *h264;
+    GetBitContext gb;
+    ERContext er;
+
+    int slice_num;
+    int slice_type;
+    int slice_type_nos;         ///< S free slice type (SI/SP are remapped to I/P)
+    int slice_type_fixed;
+
+    int qscale;
+    int chroma_qp[2];   // QPc
+    int qp_thresh;      ///< QP threshold to skip loopfilter
+    int last_qscale_diff;
+
+    // deblock
+    int deblocking_filter;          ///< disable_deblocking_filter_idc with 1 <-> 0
+    int slice_alpha_c0_offset;
+    int slice_beta_offset;
+
+    H264PredWeightTable pwt;
+
+    int prev_mb_skipped;
+    int next_mb_skipped;
+
+    int chroma_pred_mode;
+    int intra16x16_pred_mode;
+
+    int8_t intra4x4_pred_mode_cache[5 * 8];
+    int8_t(*intra4x4_pred_mode);
+
+    int topleft_mb_xy;
+    int top_mb_xy;
+    int topright_mb_xy;
+    int left_mb_xy[LEFT_MBS];
+
+    int topleft_type;
+    int top_type;
+    int topright_type;
+    int left_type[LEFT_MBS];
+
+    const uint8_t *left_block;
+    int topleft_partition;
+
+    unsigned int topleft_samples_available;
+    unsigned int top_samples_available;
+    unsigned int topright_samples_available;
+    unsigned int left_samples_available;
+
+    ptrdiff_t linesize, uvlinesize;
+    ptrdiff_t mb_linesize;  ///< may be equal to s->linesize or s->linesize * 2, for mbaff
+    ptrdiff_t mb_uvlinesize;
+
+    int mb_x, mb_y;
+    int mb_xy;
+    int resync_mb_x;
+    int resync_mb_y;
+    unsigned int first_mb_addr;
+    // index of the first MB of the next slice
+    int next_slice_idx;
+    int mb_skip_run;
+    int is_complex;
+
+    int picture_structure;
+    int mb_field_decoding_flag;
+    int mb_mbaff;               ///< mb_aff_frame && mb_field_decoding_flag
+
+    int redundant_pic_count;
+
+    /**
+     * number of neighbors (top and/or left) that used 8x8 dct
+     */
+    int neighbor_transform_size;
+
+    int direct_spatial_mv_pred;
+    int col_parity;
+    int col_fieldoff;
+
+    int cbp;
+    int top_cbp;
+    int left_cbp;
+
+    int dist_scale_factor[32];
+    int dist_scale_factor_field[2][32];
+    int map_col_to_list0[2][16 + 32];
+    int map_col_to_list0_field[2][2][16 + 32];
+
+    /**
+     * num_ref_idx_l0/1_active_minus1 + 1
+     */
+    unsigned int ref_count[2];          ///< counts frames or fields, depending on current mb mode
+    unsigned int list_count;
+    H264Ref ref_list[2][48];        /**< 0..15: frame refs, 16..47: mbaff field refs.
+                                         *   Reordered version of default_ref_list
+                                         *   according to picture reordering in slice header */
+    struct {
+        uint8_t op;
+        uint32_t val;
+    } ref_modifications[2][32];
+    int nb_ref_modifications[2];
+
+    unsigned int pps_id;
+
+    const uint8_t *intra_pcm_ptr;
+    int16_t *dc_val_base;
+
+    uint8_t *bipred_scratchpad;
+    uint8_t *edge_emu_buffer;
+    uint8_t (*top_borders[2])[(16 * 3) * 2];
+    int bipred_scratchpad_allocated;
+    int edge_emu_buffer_allocated;
+    int top_borders_allocated[2];
+
+    /**
+     * non zero coeff count cache.
+     * is 64 if not available.
+     */
+    DECLARE_ALIGNED(8, uint8_t, non_zero_count_cache)[15 * 8];
+
+    /**
+     * Motion vector cache.
+     */
+    DECLARE_ALIGNED(16, int16_t, mv_cache)[2][5 * 8][2];
+    DECLARE_ALIGNED(8,  int8_t, ref_cache)[2][5 * 8];
+    DECLARE_ALIGNED(16, uint8_t, mvd_cache)[2][5 * 8][2];
+    uint8_t direct_cache[5 * 8];
+
+    DECLARE_ALIGNED(8, uint16_t, sub_mb_type)[4];
+
+    ///< as a DCT coefficient is int32_t in high depth, we need to reserve twice the space.
+    DECLARE_ALIGNED(16, int16_t, mb)[16 * 48 * 2];
+    DECLARE_ALIGNED(16, int16_t, mb_luma_dc)[3][16 * 2];
+    ///< as mb is addressed by scantable[i] and scantable is uint8_t we can either
+    ///< check that i is not too large or ensure that there is some unused stuff after mb
+    int16_t mb_padding[256 * 2];
+
+    uint8_t (*mvd_table[2])[2];
+
+    /**
+     * Cabac
+     */
+    CABACContext cabac;
+    uint8_t cabac_state[1024];
+    int cabac_init_idc;
+
+    MMCO mmco[MAX_MMCO_COUNT];
+    int  nb_mmco;
+    int explicit_ref_marking;
+
+    int frame_num;
+    int poc_lsb;
+    int delta_poc_bottom;
+    int delta_poc[2];
+    int curr_pic_num;
+    int max_pic_num;
+} H264SliceContext;
+
+/**
+ * H264Context
+ */
+typedef struct H264Context {
+    const AVClass *class;
+    AVCodecContext *avctx;
+    VideoDSPContext vdsp;
+    H264DSPContext h264dsp;
+    H264ChromaContext h264chroma;
+    H264QpelContext h264qpel;
+
+    H264Picture DPB[H264_MAX_PICTURE_COUNT];
+    H264Picture *cur_pic_ptr;
+    H264Picture cur_pic;
+    H264Picture last_pic_for_ec;
+
+    H264SliceContext *slice_ctx;
+    int            nb_slice_ctx;
+    int            nb_slice_ctx_queued;
+
+    H2645Packet pkt;
+
+    int pixel_shift;    ///< 0 for 8-bit H.264, 1 for high-bit-depth H.264
+
+    /* coded dimensions -- 16 * mb w/h */
+    int width, height;
+    int chroma_x_shift, chroma_y_shift;
+
+    int droppable;
+    int coded_picture_number;
+
+    int context_initialized;
+    int flags;
+    int workaround_bugs;
+    int x264_build;
+    /* Set when slice threading is used and at least one slice uses deblocking
+     * mode 1 (i.e. across slice boundaries). Then we disable the loop filter
+     * during normal MB decoding and execute it serially at the end.
+     */
+    int postpone_filter;
+
+    /*
+     * Set to 1 when the current picture is IDR, 0 otherwise.
+     */
+    int picture_idr;
+
+    int crop_left;
+    int crop_right;
+    int crop_top;
+    int crop_bottom;
+
+    int8_t(*intra4x4_pred_mode);
+    H264PredContext hpc;
+
+    uint8_t (*non_zero_count)[48];
+
+#define LIST_NOT_USED -1 // FIXME rename?
+#define PART_NOT_AVAILABLE -2
+
+    /**
+     * block_offset[ 0..23] for frame macroblocks
+     * block_offset[24..47] for field macroblocks
+     */
+    int block_offset[2 * (16 * 3)];
+
+    uint32_t *mb2b_xy;  // FIXME are these 4 a good idea?
+    uint32_t *mb2br_xy;
+    int b_stride;       // FIXME use s->b4_stride
+
+    uint16_t *slice_table;      ///< slice_table_base + 2*mb_stride + 1
+
+    // interlacing specific flags
+    int mb_aff_frame;
+    int picture_structure;
+    int first_field;
+
+    uint8_t *list_counts;               ///< Array of list_count per MB specifying the slice type
+
+    /* 0x100 -> non null luma_dc, 0x80/0x40 -> non null chroma_dc (cb/cr), 0x?0 -> chroma_cbp(0, 1, 2), 0x0? luma_cbp */
+    uint16_t *cbp_table;
+
+    /* chroma_pred_mode for i4x4 or i16x16, else 0 */
+    uint8_t *chroma_pred_mode_table;
+    uint8_t (*mvd_table[2])[2];
+    uint8_t *direct_table;
+
+    uint8_t scan_padding[16];
+    uint8_t zigzag_scan[16];
+    uint8_t zigzag_scan8x8[64];
+    uint8_t zigzag_scan8x8_cavlc[64];
+    uint8_t field_scan[16];
+    uint8_t field_scan8x8[64];
+    uint8_t field_scan8x8_cavlc[64];
+    uint8_t zigzag_scan_q0[16];
+    uint8_t zigzag_scan8x8_q0[64];
+    uint8_t zigzag_scan8x8_cavlc_q0[64];
+    uint8_t field_scan_q0[16];
+    uint8_t field_scan8x8_q0[64];
+    uint8_t field_scan8x8_cavlc_q0[64];
+
+    int mb_y;
+    int mb_height, mb_width;
+    int mb_stride;
+    int mb_num;
+
+    // =============================================================
+    // Things below are not used in the MB or more inner code
+
+    int nal_ref_idc;
+    int nal_unit_type;
+
+    int has_slice;          ///< slice NAL is found in the packet, set by decode_nal_units, its state does not need to be preserved outside h264_decode_frame()
+
+    /**
+     * Used to parse AVC variant of H.264
+     */
+    int is_avc;           ///< this flag is != 0 if codec is avc1
+    int nal_length_size;  ///< Number of bytes used for nal length (1, 2 or 4)
+
+    int bit_depth_luma;         ///< luma bit depth from sps to detect changes
+    int chroma_format_idc;      ///< chroma format from sps to detect changes
+
+    H264ParamSets ps;
+
+    uint16_t *slice_table_base;
+
+    H264POCContext poc;
+
+    H264Ref default_ref[2];
+    H264Picture *short_ref[32];
+    H264Picture *long_ref[32];
+    H264Picture *delayed_pic[MAX_DELAYED_PIC_COUNT + 2]; // FIXME size?
+    int last_pocs[MAX_DELAYED_PIC_COUNT];
+    H264Picture *next_output_pic;
+    int next_outputed_poc;
+
+    /**
+     * memory management control operations buffer.
+     */
+    MMCO mmco[MAX_MMCO_COUNT];
+    int  nb_mmco;
+    int mmco_reset;
+    int explicit_ref_marking;
+
+    int long_ref_count;     ///< number of actual long term references
+    int short_ref_count;    ///< number of actual short term references
+
+    /**
+     * @name Members for slice based multithreading
+     * @{
+     */
+    /**
+     * current slice number, used to initialize slice_num of each thread/context
+     */
+    int current_slice;
+
+    /** @} */
+
+    /**
+     * Complement sei_pic_struct
+     * SEI_PIC_STRUCT_TOP_BOTTOM and SEI_PIC_STRUCT_BOTTOM_TOP indicate interlaced frames.
+     * However, soft telecined frames may have these values.
+     * This is used in an attempt to flag soft telecine progressive.
+     */
+    int prev_interlaced_frame;
+
+    /**
+     * Are the SEI recovery points looking valid.
+     */
+    int valid_recovery_point;
+
+    /**
+     * recovery_frame is the frame_num at which the next frame should
+     * be fully constructed.
+     *
+     * Set to -1 when not expecting a recovery point.
+     */
+    int recovery_frame;
+
+/**
+ * We have seen an IDR, so all the following frames in coded order are correctly
+ * decodable.
+ */
+#define FRAME_RECOVERED_IDR  (1 << 0)
+/**
+ * Sufficient number of frames have been decoded since a SEI recovery point,
+ * so all the following frames in presentation order are correct.
+ */
+#define FRAME_RECOVERED_SEI  (1 << 1)
+
+    int frame_recovered;    ///< Initial frame has been completely recovered
+
+    int has_recovery_point;
+
+    int missing_fields;
+
+    /* for frame threading, this is set to 1
+     * after finish_setup() has been called, so we cannot modify
+     * some context properties (which are supposed to stay constant between
+     * slices) anymore */
+    int setup_finished;
+
+    int cur_chroma_format_idc;
+    int cur_bit_depth_luma;
+    int16_t slice_row[MAX_SLICES]; ///< to detect when MAX_SLICES is too low
+
+    /* original AVCodecContext dimensions, used to handle container
+     * cropping */
+    int width_from_caller;
+    int height_from_caller;
+
+    int enable_er;
+
+    H264SEIContext sei;
+
+    AVBufferPool *qscale_table_pool;
+    AVBufferPool *mb_type_pool;
+    AVBufferPool *motion_val_pool;
+    AVBufferPool *ref_index_pool;
+    int ref2frm[MAX_SLICES][2][64];     ///< reference to frame number lists, used in the loop filter, the first 2 are for -2,-1
+} H264Context;
+
+extern const uint16_t ff_h264_mb_sizes[4];
+
+/**
+ * Reconstruct bitstream slice_type.
+ */
+int ff_h264_get_slice_type(const H264SliceContext *sl);
+
+/**
+ * Allocate tables.
+ * needs width/height
+ */
+int ff_h264_alloc_tables(H264Context *h);
+
+int ff_h264_decode_ref_pic_list_reordering(H264SliceContext *sl, void *logctx);
+int ff_h264_build_ref_list(H264Context *h, H264SliceContext *sl);
+void ff_h264_remove_all_refs(H264Context *h);
+
+/**
+ * Execute the reference picture marking (memory management control operations).
+ */
+int ff_h264_execute_ref_pic_marking(H264Context *h);
+
+int ff_h264_decode_ref_pic_marking(H264SliceContext *sl, GetBitContext *gb,
+                                   const H2645NAL *nal, void *logctx);
+
+void ff_h264_hl_decode_mb(const H264Context *h, H264SliceContext *sl);
+void ff_h264_decode_init_vlc(void);
+
+/**
+ * Decode a macroblock
+ * @return 0 if OK, ER_AC_ERROR / ER_DC_ERROR / ER_MV_ERROR on error
+ */
+int ff_h264_decode_mb_cavlc(const H264Context *h, H264SliceContext *sl);
+
+/**
+ * Decode a CABAC coded macroblock
+ * @return 0 if OK, ER_AC_ERROR / ER_DC_ERROR / ER_MV_ERROR on error
+ */
+int ff_h264_decode_mb_cabac(const H264Context *h, H264SliceContext *sl);
+
+void ff_h264_init_cabac_states(const H264Context *h, H264SliceContext *sl);
+
+void ff_h264_direct_dist_scale_factor(const H264Context *const h, H264SliceContext *sl);
+void ff_h264_direct_ref_list_init(const H264Context *const h, H264SliceContext *sl);
+void ff_h264_pred_direct_motion(const H264Context *const h, H264SliceContext *sl,
+                                int *mb_type);
+
+void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl, int mb_x, int mb_y,
+                            uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr,
+                            unsigned int linesize, unsigned int uvlinesize);
+void ff_h264_filter_mb(const H264Context *h, H264SliceContext *sl, int mb_x, int mb_y,
+                       uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr,
+                       unsigned int linesize, unsigned int uvlinesize);
+
+/*
+ * o-o o-o
+ *  / / /
+ * o-o o-o
+ *  ,---'
+ * o-o o-o
+ *  / / /
+ * o-o o-o
+ */
+
+/* Scan8 organization:
+ *    0 1 2 3 4 5 6 7
+ * 0  DY    y y y y y
+ * 1        y Y Y Y Y
+ * 2        y Y Y Y Y
+ * 3        y Y Y Y Y
+ * 4        y Y Y Y Y
+ * 5  DU    u u u u u
+ * 6        u U U U U
+ * 7        u U U U U
+ * 8        u U U U U
+ * 9        u U U U U
+ * 10 DV    v v v v v
+ * 11       v V V V V
+ * 12       v V V V V
+ * 13       v V V V V
+ * 14       v V V V V
+ * DY/DU/DV are for luma/chroma DC.
+ */
+
+#define LUMA_DC_BLOCK_INDEX   48
+#define CHROMA_DC_BLOCK_INDEX 49
+
+// This table must be here because scan8[constant] must be known at compiletime
+static const uint8_t scan8[16 * 3 + 3] = {
+    4 +  1 * 8, 5 +  1 * 8, 4 +  2 * 8, 5 +  2 * 8,
+    6 +  1 * 8, 7 +  1 * 8, 6 +  2 * 8, 7 +  2 * 8,
+    4 +  3 * 8, 5 +  3 * 8, 4 +  4 * 8, 5 +  4 * 8,
+    6 +  3 * 8, 7 +  3 * 8, 6 +  4 * 8, 7 +  4 * 8,
+    4 +  6 * 8, 5 +  6 * 8, 4 +  7 * 8, 5 +  7 * 8,
+    6 +  6 * 8, 7 +  6 * 8, 6 +  7 * 8, 7 +  7 * 8,
+    4 +  8 * 8, 5 +  8 * 8, 4 +  9 * 8, 5 +  9 * 8,
+    6 +  8 * 8, 7 +  8 * 8, 6 +  9 * 8, 7 +  9 * 8,
+    4 + 11 * 8, 5 + 11 * 8, 4 + 12 * 8, 5 + 12 * 8,
+    6 + 11 * 8, 7 + 11 * 8, 6 + 12 * 8, 7 + 12 * 8,
+    4 + 13 * 8, 5 + 13 * 8, 4 + 14 * 8, 5 + 14 * 8,
+    6 + 13 * 8, 7 + 13 * 8, 6 + 14 * 8, 7 + 14 * 8,
+    0 +  0 * 8, 0 +  5 * 8, 0 + 10 * 8
+};
+
+static av_always_inline uint32_t pack16to32(unsigned a, unsigned b)
+{
+#if HAVE_BIGENDIAN
+    return (b & 0xFFFF) + (a << 16);
+#else
+    return (a & 0xFFFF) + (b << 16);
+#endif
+}
+
+static av_always_inline uint16_t pack8to16(unsigned a, unsigned b)
+{
+#if HAVE_BIGENDIAN
+    return (b & 0xFF) + (a << 8);
+#else
+    return (a & 0xFF) + (b << 8);
+#endif
+}
+
+/**
+ * Get the chroma qp.
+ */
+static av_always_inline int get_chroma_qp(const PPS *pps, int t, int qscale)
+{
+    return pps->chroma_qp_table[t][qscale];
+}
+
+/**
+ * Get the predicted intra4x4 prediction mode.
+ */
+static av_always_inline int pred_intra_mode(const H264Context *h,
+                                            H264SliceContext *sl, int n)
+{
+    const int index8 = scan8[n];
+    const int left   = sl->intra4x4_pred_mode_cache[index8 - 1];
+    const int top    = sl->intra4x4_pred_mode_cache[index8 - 8];
+    const int min    = FFMIN(left, top);
+
+    ff_tlog(h->avctx, "mode:%d %d min:%d\n", left, top, min);
+
+    if (min < 0)
+        return DC_PRED;
+    else
+        return min;
+}
+
+static av_always_inline void write_back_intra_pred_mode(const H264Context *h,
+                                                        H264SliceContext *sl)
+{
+    int8_t *i4x4       = sl->intra4x4_pred_mode + h->mb2br_xy[sl->mb_xy];
+    int8_t *i4x4_cache = sl->intra4x4_pred_mode_cache;
+
+    AV_COPY32(i4x4, i4x4_cache + 4 + 8 * 4);
+    i4x4[4] = i4x4_cache[7 + 8 * 3];
+    i4x4[5] = i4x4_cache[7 + 8 * 2];
+    i4x4[6] = i4x4_cache[7 + 8 * 1];
+}
+
+static av_always_inline void write_back_non_zero_count(const H264Context *h,
+                                                       H264SliceContext *sl)
+{
+    const int mb_xy    = sl->mb_xy;
+    uint8_t *nnz       = h->non_zero_count[mb_xy];
+    uint8_t *nnz_cache = sl->non_zero_count_cache;
+
+    AV_COPY32(&nnz[ 0], &nnz_cache[4 + 8 * 1]);
+    AV_COPY32(&nnz[ 4], &nnz_cache[4 + 8 * 2]);
+    AV_COPY32(&nnz[ 8], &nnz_cache[4 + 8 * 3]);
+    AV_COPY32(&nnz[12], &nnz_cache[4 + 8 * 4]);
+    AV_COPY32(&nnz[16], &nnz_cache[4 + 8 * 6]);
+    AV_COPY32(&nnz[20], &nnz_cache[4 + 8 * 7]);
+    AV_COPY32(&nnz[32], &nnz_cache[4 + 8 * 11]);
+    AV_COPY32(&nnz[36], &nnz_cache[4 + 8 * 12]);
+
+    if (!h->chroma_y_shift) {
+        AV_COPY32(&nnz[24], &nnz_cache[4 + 8 * 8]);
+        AV_COPY32(&nnz[28], &nnz_cache[4 + 8 * 9]);
+        AV_COPY32(&nnz[40], &nnz_cache[4 + 8 * 13]);
+        AV_COPY32(&nnz[44], &nnz_cache[4 + 8 * 14]);
+    }
+}
+
+static av_always_inline void write_back_motion_list(const H264Context *h,
+                                                    H264SliceContext *sl,
+                                                    int b_stride,
+                                                    int b_xy, int b8_xy,
+                                                    int mb_type, int list)
+{
+    int16_t(*mv_dst)[2] = &h->cur_pic.motion_val[list][b_xy];
+    int16_t(*mv_src)[2] = &sl->mv_cache[list][scan8[0]];
+    AV_COPY128(mv_dst + 0 * b_stride, mv_src + 8 * 0);
+    AV_COPY128(mv_dst + 1 * b_stride, mv_src + 8 * 1);
+    AV_COPY128(mv_dst + 2 * b_stride, mv_src + 8 * 2);
+    AV_COPY128(mv_dst + 3 * b_stride, mv_src + 8 * 3);
+    if (CABAC(h)) {
+        uint8_t (*mvd_dst)[2] = &sl->mvd_table[list][FMO ? 8 * sl->mb_xy
+                                                        : h->mb2br_xy[sl->mb_xy]];
+        uint8_t(*mvd_src)[2]  = &sl->mvd_cache[list][scan8[0]];
+        if (IS_SKIP(mb_type)) {
+            AV_ZERO128(mvd_dst);
+        } else {
+            AV_COPY64(mvd_dst, mvd_src + 8 * 3);
+            AV_COPY16(mvd_dst + 3 + 3, mvd_src + 3 + 8 * 0);
+            AV_COPY16(mvd_dst + 3 + 2, mvd_src + 3 + 8 * 1);
+            AV_COPY16(mvd_dst + 3 + 1, mvd_src + 3 + 8 * 2);
+        }
+    }
+
+    {
+        int8_t *ref_index = &h->cur_pic.ref_index[list][b8_xy];
+        int8_t *ref_cache = sl->ref_cache[list];
+        ref_index[0 + 0 * 2] = ref_cache[scan8[0]];
+        ref_index[1 + 0 * 2] = ref_cache[scan8[4]];
+        ref_index[0 + 1 * 2] = ref_cache[scan8[8]];
+        ref_index[1 + 1 * 2] = ref_cache[scan8[12]];
+    }
+}
+
+static av_always_inline void write_back_motion(const H264Context *h,
+                                               H264SliceContext *sl,
+                                               int mb_type)
+{
+    const int b_stride      = h->b_stride;
+    const int b_xy  = 4 * sl->mb_x + 4 * sl->mb_y * h->b_stride; // try mb2b(8)_xy
+    const int b8_xy = 4 * sl->mb_xy;
+
+    if (USES_LIST(mb_type, 0)) {
+        write_back_motion_list(h, sl, b_stride, b_xy, b8_xy, mb_type, 0);
+    } else {
+        fill_rectangle(&h->cur_pic.ref_index[0][b8_xy],
+                       2, 2, 2, (uint8_t)LIST_NOT_USED, 1);
+    }
+    if (USES_LIST(mb_type, 1))
+        write_back_motion_list(h, sl, b_stride, b_xy, b8_xy, mb_type, 1);
+
+    if (sl->slice_type_nos == AV_PICTURE_TYPE_B && CABAC(h)) {
+        if (IS_8X8(mb_type)) {
+            uint8_t *direct_table = &h->direct_table[4 * sl->mb_xy];
+            direct_table[1] = sl->sub_mb_type[1] >> 1;
+            direct_table[2] = sl->sub_mb_type[2] >> 1;
+            direct_table[3] = sl->sub_mb_type[3] >> 1;
+        }
+    }
+}
+
+static av_always_inline int get_dct8x8_allowed(const H264Context *h, H264SliceContext *sl)
+{
+    if (h->ps.sps->direct_8x8_inference_flag)
+        return !(AV_RN64A(sl->sub_mb_type) &
+                 ((MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_8x8) *
+                  0x0001000100010001ULL));
+    else
+        return !(AV_RN64A(sl->sub_mb_type) &
+                 ((MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_8x8 | MB_TYPE_DIRECT2) *
+                  0x0001000100010001ULL));
+}
+
+static inline int find_start_code(const uint8_t *buf, int buf_size,
+                           int buf_index, int next_avc)
+{
+    uint32_t state = -1;
+
+    buf_index = avpriv_find_start_code(buf + buf_index, buf + next_avc + 1, &state) - buf - 1;
+
+    return FFMIN(buf_index, buf_size);
+}
+
+int ff_h264_field_end(H264Context *h, H264SliceContext *sl, int in_setup);
+
+int ff_h264_ref_picture(H264Context *h, H264Picture *dst, H264Picture *src);
+void ff_h264_unref_picture(H264Context *h, H264Picture *pic);
+
+int ff_h264_slice_context_init(H264Context *h, H264SliceContext *sl);
+
+void ff_h264_draw_horiz_band(const H264Context *h, H264SliceContext *sl, int y, int height);
+
+int ff_h264_decode_slice_header(H264Context *h, H264SliceContext *sl,
+                                const H2645NAL *nal);
+/**
+ * Submit a slice for decoding.
+ *
+ * Parse the slice header, starting a new field/frame if necessary. If any
+ * slices are queued for the previous field, they are decoded.
+ */
+int ff_h264_queue_decode_slice(H264Context *h, const H2645NAL *nal);
+int ff_h264_execute_decode_slices(H264Context *h);
+int ff_h264_update_thread_context(AVCodecContext *dst,
+                                  const AVCodecContext *src);
+
+void ff_h264_flush_change(H264Context *h);
+
+void ff_h264_free_tables(H264Context *h);
+
+void ff_h264_set_erpic(ERPicture *dst, H264Picture *src);
+
+#endif /* AVCODEC_H264DEC_H */
-- 
2.23.0

